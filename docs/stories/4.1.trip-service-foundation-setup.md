# Story 4.1: TripService Foundation & Health Check

## Status

Draft

## Story

**As a** developer,
**I want** a separate TripService containerized with its own database,
**so that** trip management is isolated following microservices principles.

## Acceptance Criteria

1. TripService directory created with project structure following service conventions
2. Dockerfile created for TripService with multi-stage build
3. docker-compose.yml updated to include TripService container
4. TripService exposes `GET /health` endpoint returning 200 status
5. TripService connects to its own database (PostgreSQL)
6. Database connection verification included in health check
7. Service starts successfully with `docker-compose up` alongside other services
8. README.md updated with TripService setup instructions
9. Unit tests cover health check endpoint
10. CI/CD pipeline updated to build and test TripService

## Tasks / Subtasks

- [ ] **Task 1: Create TripService Project Structure** (AC: 1)
  - [ ] Create `services/trip-service/` directory
  - [ ] Initialize NestJS project: `nest new trip-service` (or copy from user-service template)
  - [ ] Create standard directory structure: `src/health/`, `src/trips/`, `src/common/`, `src/config/`
  - [ ] Copy common files from user-service: `.eslintrc.js`, `.prettierrc`, `tsconfig.json`, `nest-cli.json`
  - [ ] Create `test/unit/` and `test/integration/` directories
  - [ ] Initialize `package.json` with required dependencies: `@nestjs/core`, `@nestjs/common`, `@nestjs/platform-express`, `@prisma/client`, `prisma`
  - [ ] Add test dependencies: `@nestjs/testing`, `jest`, `supertest`, `@types/jest`, `@types/supertest`

- [ ] **Task 2: Setup PostgreSQL Database with Prisma** (AC: 5, 6)
  - [ ] Create `services/trip-service/prisma/` directory
  - [ ] Initialize Prisma: `npx prisma init`
  - [ ] Create `prisma/schema.prisma` with database connection and client generator
  - [ ] Configure datasource to use `DATABASE_URL` environment variable
  - [ ] Create initial empty migration to establish database: `npx prisma migrate dev --name init`
  - [ ] Create PrismaService module: `src/prisma/prisma.service.ts` extending `PrismaClient` with NestJS lifecycle hooks
  - [ ] Create PrismaModule: `src/prisma/prisma.module.ts` to export PrismaService
  - [ ] Add database connection check method to PrismaService: `checkConnection()` using `prisma.$queryRaw`

- [ ] **Task 3: Implement Health Check Endpoint** (AC: 4, 6)
  - [ ] Create `src/health/health.controller.ts` with `GET /health` endpoint
  - [ ] Implement health check logic:
    - [ ] Return `{ status: 'healthy', timestamp: Date, service: 'trip-service', version: '1.0.0' }` when database is connected
    - [ ] Check database connection using PrismaService.checkConnection()
    - [ ] Return 200 OK status when healthy
    - [ ] Return 503 Service Unavailable if database is not reachable
  - [ ] Create HealthModule and import PrismaModule
  - [ ] Register HealthController in HealthModule
  - [ ] Import HealthModule in AppModule

- [ ] **Task 4: Create Dockerfile with Multi-Stage Build** (AC: 2)
  - [ ] Create `services/trip-service/Dockerfile`
  - [ ] Stage 1 (Dependencies): Install all dependencies including devDependencies
  - [ ] Stage 2 (Build): Run `prisma generate`, compile TypeScript with `nest build`
  - [ ] Stage 3 (Production): Copy only production dependencies, built dist/, and prisma/ folder
  - [ ] Set Node environment to production: `ENV NODE_ENV=production`
  - [ ] Expose port 3002 (TripService port convention)
  - [ ] Set CMD to run compiled application: `node dist/main.js`
  - [ ] Add `.dockerignore` file: exclude `node_modules/`, `dist/`, `coverage/`, `.env`

- [ ] **Task 5: Update Docker Compose Configuration** (AC: 3, 7)
  - [ ] Add `trip-service` container to `docker-compose.yml`:
    - [ ] Build context: `./services/trip-service`
    - [ ] Container name: `trip-service`
    - [ ] Port mapping: `3002:3002`
    - [ ] Environment variables: `DATABASE_URL` (pointing to trip-db), `PORT=3002`
    - [ ] Depends on: `trip-db`
  - [ ] Add `trip-db` PostgreSQL container:
    - [ ] Image: `postgres:15-alpine`
    - [ ] Container name: `trip-db`
    - [ ] Environment: `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB=tripservice`
    - [ ] Volume: `trip-db-data:/var/lib/postgresql/data`
    - [ ] Port mapping: `5433:5432` (to avoid conflict with user-service db)
  - [ ] Add `trip-db-data` named volume to volumes section
  - [ ] Test: Run `docker-compose up` and verify all services start successfully

- [ ] **Task 6: Configure Environment Variables** (AC: 5)
  - [ ] Create `services/trip-service/.env.example` template:
    - [ ] `DATABASE_URL=postgresql://user:pass@trip-db:5432/tripservice`
    - [ ] `PORT=3002`
    - [ ] `NODE_ENV=development`
  - [ ] Create `services/trip-service/.env` for local development (gitignored)
  - [ ] Document environment variables in README.md

- [ ] **Task 7: Write Unit Tests** (AC: 9)
  - [ ] Create `test/unit/health/health.controller.spec.ts`
  - [ ] Test: GET /health returns 200 with correct JSON structure when database is connected
  - [ ] Test: GET /health returns 503 when database connection fails
  - [ ] Test: Response includes `status`, `timestamp`, `service`, `version` fields
  - [ ] Mock PrismaService.checkConnection() to test both success and failure scenarios
  - [ ] Ensure tests pass: `npm test`

- [ ] **Task 8: Write Integration Tests** (AC: 9)
  - [ ] Create `test/integration/health.e2e-spec.ts`
  - [ ] Setup: Start test app with TestingModule
  - [ ] Test: GET /health endpoint returns 200 and valid JSON with real database connection
  - [ ] Test: Health endpoint is accessible without authentication
  - [ ] Cleanup: Close app and disconnect Prisma after tests
  - [ ] Ensure integration tests pass: `npm run test:e2e`

- [ ] **Task 9: Update Documentation** (AC: 8)
  - [ ] Create `services/trip-service/README.md`:
    - [ ] Service description: "TripService manages ride requests, trip lifecycle, and fare calculations"
    - [ ] Prerequisites: Node.js 20.x, Docker, pnpm
    - [ ] Setup instructions:
      - [ ] Install dependencies: `pnpm install`
      - [ ] Copy `.env.example` to `.env` and configure
      - [ ] Run database migrations: `npx prisma migrate dev`
      - [ ] Start service: `pnpm run start:dev`
    - [ ] Docker instructions:
      - [ ] Build: `docker build -t trip-service .`
      - [ ] Run with docker-compose: `docker-compose up trip-service`
    - [ ] API endpoints (initially just /health)
    - [ ] Testing instructions: `pnpm test`, `pnpm test:e2e`
  - [ ] Update root `README.md` to mention TripService

- [ ] **Task 10: Update CI/CD Pipeline** (AC: 10)
  - [ ] Update `.github/workflows/ci.yml`:
    - [ ] Add job for trip-service: `test-trip-service`
    - [ ] Checkout code
    - [ ] Setup Node.js 20.x
    - [ ] Install pnpm
    - [ ] Install dependencies: `pnpm --filter trip-service install`
    - [ ] Setup PostgreSQL service for tests (GitHub Actions service container)
    - [ ] Run Prisma migrations: `npx prisma migrate deploy`
    - [ ] Run unit tests: `pnpm --filter trip-service test`
    - [ ] Run integration tests: `pnpm --filter trip-service test:e2e`
    - [ ] Upload coverage reports
  - [ ] Update `.github/workflows/build-and-push.yml` (if exists):
    - [ ] Add Docker build step for trip-service
    - [ ] Tag image: `trip-service:latest`
    - [ ] Push to ECR (if configured)

## Dev Notes

### Epic Context

This is the first story in **Epic 4: Trip Lifecycle & Ride Matching**. Epic 4 builds the TripService to manage the complete ride request and matching workflow, including trip creation with fare estimation, driver notification, acceptance/decline logic with timeout, and trip state management.

This foundation story establishes the TripService infrastructure following the same patterns used in Epic 1 (UserService foundation) and Epic 3 (DriverService foundation). All three microservices follow identical setup patterns for consistency.

### Previous Story Insights

**From Story 1.2 (UserService Setup):**

- NestJS project structure with `src/` containing feature modules (auth, users, etc.)
- Prisma ORM for PostgreSQL with migrations in `prisma/migrations/`
- Health check endpoint pattern: `GET /health` returning `{ status, timestamp, service, version }`
- Docker multi-stage build: dependencies → build → production image
- Environment variables managed through `.env` files (gitignored)
- Testing structure: `test/unit/` and `test/integration/` directories
- CI/CD pipeline runs tests with PostgreSQL service container

**From Story 3.1 (DriverService Setup):**

- Similar service foundation but with Redis instead of SQL
- Health check includes external dependency verification (database/Redis connection)
- Docker compose includes both service container and database container
- Port allocation: UserService (3001), DriverService (3003), **TripService will use 3002**
- Service naming convention: `{service}-service` and `{service}-db` containers

**Key Pattern to Follow:**
All microservices use identical project structure, testing approach, and Docker configuration. Copy the best practices from UserService and DriverService to ensure consistency.

### Architecture Context

[Source: architecture/section-3-tech-stack.md]

**Technology Stack for TripService:**

- **Backend Framework:** NestJS 10.x
- **Language:** TypeScript 5.3.x
- **Database:** PostgreSQL 15.x (via AWS RDS in production, Docker container locally)
- **ORM:** Prisma 5.x
- **Testing:** Jest 29.x for unit tests, Supertest 6.x for integration tests
- **Containerization:** Docker 24.x with multi-stage builds
- **Package Manager:** pnpm 8.x

[Source: architecture/section-10-unified-project-structure.md]

**TripService Directory Structure:**

```
services/trip-service/
├── src/
│   ├── trips/                        # Trip management feature module (created in later stories)
│   │   ├── trips.controller.ts
│   │   ├── trips.service.ts
│   │   ├── trips.repository.ts
│   │   └── dto/
│   ├── common/                       # Cross-cutting concerns
│   │   ├── filters/
│   │   ├── interceptors/
│   │   └── guards/
│   ├── config/                       # Configuration modules
│   │   ├── database.config.ts
│   │   └── services.config.ts
│   ├── health/                       # Health check endpoint (THIS STORY)
│   │   └── health.controller.ts
│   ├── integrations/                 # External service clients (for later stories)
│   │   ├── user-service.client.ts
│   │   └── driver-service.client.ts
│   ├── prisma/                       # Prisma service module
│   │   ├── prisma.service.ts
│   │   └── prisma.module.ts
│   ├── app.module.ts                 # Root module
│   └── main.ts                       # Bootstrap application
├── prisma/
│   ├── schema.prisma                 # Database schema
│   ├── migrations/                   # Migration files
│   └── seed.ts                       # Seed data (optional)
├── test/
│   ├── unit/
│   │   └── health/
│   │       └── health.controller.spec.ts
│   ├── integration/
│   │   └── health.e2e-spec.ts
│   └── test-utils.ts
├── Dockerfile                        # Multi-stage Docker build
├── .env.example                      # Environment variable template
├── .dockerignore
├── package.json
├── tsconfig.json
├── nest-cli.json
├── jest.config.js
└── README.md
```

[Source: architecture/section-9-database-schema.md#9.2-tripservice-database-schema]

**Initial Database Schema (Empty for This Story):**
In this foundation story, we only establish the database connection infrastructure. The actual `trips` table will be created in Story 4.3 (Create Trip Request). For now, Prisma schema contains only the datasource and generator configuration:

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Trip model will be added in Story 4.3
```

[Source: architecture/section-15-coding-standards.md]

**Critical Coding Standards:**

- **Type Safety:** TypeScript strict mode enabled, never use `any` type
- **Prisma Best Practices:** Always use Prisma-generated types, never manual database models
- **Environment Variables:** Access via NestJS ConfigModule, never `process.env` directly in business logic
- **Error Handling:** All endpoints use NestJS exception filters (NotFoundException, BadRequestException, etc.)
- **Health Check Pattern:** Return `{ status: 'healthy' | 'unhealthy', timestamp: string, service: string, version: string }`
- **HTTP Status Codes:** 200 (OK), 503 (Service Unavailable for unhealthy)
- **Dependency Injection:** Use NestJS DI, never instantiate services with `new`

**Health Check Implementation Pattern:**

```typescript
@Controller('health')
export class HealthController {
  constructor(private readonly prisma: PrismaService) {}

  @Get()
  async checkHealth() {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        service: 'trip-service',
        version: '1.0.0',
        database: 'connected',
      };
    } catch (error) {
      throw new ServiceUnavailableException({
        status: 'unhealthy',
        timestamp: new Date().toISOString(),
        service: 'trip-service',
        version: '1.0.0',
        database: 'disconnected',
        error: error.message,
      });
    }
  }
}
```

[Source: architecture/section-14-testing-strategy.md]

**Testing Requirements:**

**Unit Tests (`test/unit/health/health.controller.spec.ts`):**

- Mock PrismaService with jest.fn()
- Test successful health check (200 OK with correct JSON structure)
- Test database connection failure (503 Service Unavailable)
- Verify response fields: `status`, `timestamp`, `service`, `version`, `database`
- No actual database connection needed (mocked)

**Integration Tests (`test/integration/health.e2e-spec.ts`):**

- Use actual NestJS TestingModule with real PrismaService
- Test against real PostgreSQL test database
- Verify /health endpoint returns 200 with valid JSON
- Verify endpoint is accessible without authentication
- Clean up: disconnect Prisma client after tests

**Test Commands:**

- Run unit tests: `pnpm test`
- Run integration tests: `pnpm test:e2e`
- Run with coverage: `pnpm test:cov`
- Coverage threshold: 80% minimum

**Docker Configuration:**

[Source: architecture/section-2-high-level-architecture.md]

**Port Allocation:**

- UserService: 3001
- TripService: **3002** (THIS SERVICE)
- DriverService: 3003

**Database Ports (External):**

- user-db: 5432 (default, or 5431 if mapped)
- trip-db: **5433** (to avoid conflict with user-db)
- Redis (DriverService): 6379

**Multi-Stage Dockerfile Pattern:**

```dockerfile
# Stage 1: Dependencies
FROM node:20-alpine AS deps
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm@8 && pnpm install --frozen-lockfile

# Stage 2: Build
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npx prisma generate
RUN npm run build

# Stage 3: Production
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/prisma ./prisma
COPY package.json ./
EXPOSE 3002
CMD ["node", "dist/main.js"]
```

**docker-compose.yml Addition:**

```yaml
services:
  trip-service:
    build:
      context: ./services/trip-service
      dockerfile: Dockerfile
    container_name: trip-service
    ports:
      - '3002:3002'
    environment:
      DATABASE_URL: postgresql://tripuser:trippass@trip-db:5432/tripservice
      PORT: 3002
      NODE_ENV: development
    depends_on:
      - trip-db
    restart: unless-stopped

  trip-db:
    image: postgres:15-alpine
    container_name: trip-db
    environment:
      POSTGRES_USER: tripuser
      POSTGRES_PASSWORD: trippass
      POSTGRES_DB: tripservice
    ports:
      - '5433:5432'
    volumes:
      - trip-db-data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  trip-db-data:
```

### Service Integration Notes

**No External Service Calls in This Story:**
This foundation story only establishes the TripService infrastructure. Later stories (4.3, 4.4) will add integration clients for UserService (to fetch user/driver details) and DriverService (to search nearby drivers). For now, the service is completely standalone.

**Future Integration Points (Not Implemented Yet):**

- `src/integrations/user-service.client.ts`: Will call UserService REST API to fetch user and driver profile info
- `src/integrations/driver-service.client.ts`: Will call DriverService REST API to search nearby drivers and update driver status

### Testing

[Source: architecture/section-14-testing-strategy.md]

**Test File Locations:**

- Unit tests: `services/trip-service/test/unit/health/health.controller.spec.ts`
- Integration tests: `services/trip-service/test/integration/health.e2e-spec.ts`

**Unit Test Structure:**

```typescript
describe('HealthController', () => {
  let controller: HealthController;
  let prismaService: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [HealthController],
      providers: [
        {
          provide: PrismaService,
          useValue: {
            $queryRaw: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<HealthController>(HealthController);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  it('should return healthy status when database is connected', async () => {
    jest.spyOn(prismaService, '$queryRaw').mockResolvedValue([{ '?column?': 1 }]);

    const result = await controller.checkHealth();

    expect(result.status).toBe('healthy');
    expect(result.service).toBe('trip-service');
    expect(result.database).toBe('connected');
  });

  it('should throw ServiceUnavailableException when database is not connected', async () => {
    jest.spyOn(prismaService, '$queryRaw').mockRejectedValue(new Error('Connection failed'));

    await expect(controller.checkHealth()).rejects.toThrow(ServiceUnavailableException);
  });
});
```

**Integration Test Structure:**

```typescript
describe('Health Check (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  it('/health (GET) should return 200 with health status', () => {
    return request(app.getHttpServer())
      .get('/health')
      .expect(200)
      .expect((res) => {
        expect(res.body).toHaveProperty('status', 'healthy');
        expect(res.body).toHaveProperty('timestamp');
        expect(res.body).toHaveProperty('service', 'trip-service');
        expect(res.body).toHaveProperty('database', 'connected');
      });
  });
});
```

### CI/CD Pipeline Configuration

[Source: architecture/section-11-development-workflow.md]

**GitHub Actions Workflow for TripService:**

The CI pipeline must:

1. Checkout code
2. Setup Node.js 20.x
3. Install pnpm
4. Install dependencies for trip-service only (workspace filter)
5. Start PostgreSQL service container (GitHub Actions service)
6. Run database migrations with Prisma
7. Run unit tests
8. Run integration tests
9. Upload test coverage reports
10. Build Docker image (on main branch only)

**PostgreSQL Service Container Configuration:**

```yaml
services:
  postgres:
    image: postgres:15-alpine
    env:
      POSTGRES_USER: testuser
      POSTGRES_PASSWORD: testpass
      POSTGRES_DB: tripservice_test
    ports:
      - 5432:5432
    options: >-
      --health-cmd pg_isready
      --health-interval 10s
      --health-timeout 5s
      --health-retries 5
```

## Change Log

| Date       | Version | Description   | Author   |
| ---------- | ------- | ------------- | -------- |
| 2025-10-28 | 0.1     | Story created | SM (Bob) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
